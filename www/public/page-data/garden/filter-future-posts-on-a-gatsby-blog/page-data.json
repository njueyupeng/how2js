{"componentChunkName":"component---src-templates-garden-tsx","path":"/garden/filter-future-posts-on-a-gatsby-blog","result":{"data":{"garden":{"title":"Filter Future Posts on a Gatsby Blog","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Filter Future Posts on a Gatsby Blog\",\n  \"date\": \"2020-01-18T00:00:00.000Z\",\n  \"lastUpdated\": \"2021-04-26T00:00:00.000Z\",\n  \"icon\": \"gatsby\",\n  \"tags\": [\"Gatsby\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You can leverage Gatsby\\u2019s GraphQL data layer to filter blog posts that are in the future. This \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"TODAY\"), \" variable allows you to e.g. build your site once a day and automatically have it published. A use case would be a podcast website where the author recorded the episode and already has written the description in advance. This way you also don\\u2019t have to worry about remembering setting a \\u201Cdraft\\u201D variable or to be able to push changes up when you want something published.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"If you need a TL;DR:\"), \" You can visit the final example on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/blogposts-in-future-field-4iuvp\"\n  }, \"Codesandbox\"), \" (have a look at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" and the filtering in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/pages/index.js\"), \").\"), mdx(\"h2\", {\n    \"id\": \"setup\"\n  }, \"Setup\"), mdx(\"p\", null, \"Install \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/gatsbyjs/gatsby-starter-blog\"\n  }, \"gatsby-starter-blog\"), \" with Gatsby\\u2019s CLI:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"gatsby new my-blog-starter https://github.com/gatsbyjs/gatsby-starter-blog\\n\")), mdx(\"p\", null, \"When starting the development server you\\u2019ll see an overview of all posts on the index page. The end goal is to filter out all future posts from this list.\"), mdx(\"p\", null, \"First, you should change the date on one post inside \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"content/blog\"), \" to a future date. In the linked Codesandbox the post \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new-beginnings\"), \" was changed. You will still see all posts in the overview.\"), mdx(\"p\", null, \"Stop the development server and install a function from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://lodash.com/\"\n  }, \"Lodash\"), \" that you\\u2019ll use in the next step:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"npm install lodash.get\\n\")), mdx(\"h2\", {\n    \"id\": \"creating-the-extension\"\n  }, \"Creating the extension\"), mdx(\"p\", null, \"Open your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file and add the installed package, and the boilerplate to use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/\"\n  }, \"Gatsby\\u2019s schema customization API\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=gatsby-node.js\",\n    \"title\": \"gatsby-node.js\"\n  }, \"const get = require(\\\"lodash.get\\\");\\n\\nexports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes, createFieldExtension } = actions;\\n};\\n\")), mdx(\"p\", null, \"With the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createTypes\"), \" you\\u2019ll explicitly define the GraphQL types (in this case in GraphQL \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51\"\n  }, \"SDL\"), \" syntax), with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createFieldExtension\"), \" you\\u2019ll create a so called directive/extension that you then can reuse throughout your types.\"), mdx(\"p\", null, \"Since gatsby-starter-blog is powered by Markdown you\\u2019ll want to add your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \" field to the markdown type. It\\u2019s called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \" \\u2014 you are probably used to querying that in GraphQL queries. Going to GraphiQL (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"localhost:8000/___graphql\"), \") and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Docs\"), \" (top right corner) => \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Query\"), \" also reveals all available types.\"), mdx(\"p\", null, \"Adding this type definition defines the mentioned field at the root of the Markdown type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=gatsby-node.js {6-10}\",\n    \"title\": \"gatsby-node.js\",\n    \"{6-10}\": true\n  }, \"const get = require(\\\"lodash.get\\\");\\n\\nexports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes, createFieldExtension } = actions;\\n\\n  createTypes(`\\n    type MarkdownRemark implements Node {\\n      isFuture: Boolean!\\n    }\\n  `);\\n};\\n\")), mdx(\"p\", null, \"The notation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Boolean!\"), \" means that the field is of type Boolean and is Non-Nullable.\"), mdx(\"h3\", {\n    \"id\": \"creating-the-helper-function\"\n  }, \"Creating the helper function\"), mdx(\"p\", null, \"In the next step you\\u2019ll create the helper function that returns either true or false depending on whether the input date is in the future or not.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=gatsby-node.js {6-9}\",\n    \"title\": \"gatsby-node.js\",\n    \"{6-9}\": true\n  }, \"const get = require(\\\"lodash.get\\\");\\n\\nexports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes, createFieldExtension } = actions;\\n\\n  const isFuture = (fieldName) => (source) => {\\n    const date = get(source, fieldName);\\n    return new Date(date) > new Date();\\n  };\\n\\n  createTypes(`\\n    type MarkdownRemark implements Node {\\n      isFuture: Boolean!\\n    }\\n  `);\\n};\\n\")), mdx(\"p\", null, \"The concept used there is called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Currying\"\n  }, \"Currying\"), \". For this example it means:\"), mdx(\"p\", null, \"If you run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture(\\\"myName\\\")\"), \" you\\u2019ll receive a function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"(source) => {\\n  const date = get(source, \\\"myName\\\");\\n  return new Date(date) > new Date();\\n};\\n\")), mdx(\"p\", null, \"So what is that function doing? With the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lodash.get\"), \" function you\\u2019re able to input a string with only one word (e.g. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"myName\"), \") or a word with dot notation (e.g. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"myName.field\"), \"). The latter is used to access information in objects. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lodash.get\"), \" function translates the string and enables you to access that information. If you later \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log(source)\"), \" you\\u2019ll see that you have access to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"source.frontmatter\"), \" and other fields. It then checks the date with the current date and returns true if it\\u2019s in the future, otherwise false.\"), mdx(\"p\", null, \"Next, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createFieldExtension\"), \" and the just created \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=gatsby-node.js {11-21}\",\n    \"title\": \"gatsby-node.js\",\n    \"{11-21}\": true\n  }, \"const get = require(\\\"lodash.get\\\");\\n\\nexports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes, createFieldExtension } = actions;\\n\\n  const isFuture = (fieldName) => (source) => {\\n    const date = get(source, fieldName);\\n    return new Date(date) > new Date();\\n  };\\n\\n  createFieldExtension({\\n    name: \\\"isFuture\\\",\\n    args: {\\n      fieldName: \\\"String!\\\",\\n    },\\n    extend({ fieldName }) {\\n      return {\\n        resolve: isFuture(fieldName),\\n      };\\n    },\\n  });\\n\\n  createTypes(`\\n    type MarkdownRemark implements Node {\\n      isFuture: Boolean!\\n    }\\n  `);\\n};\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createFieldExtension\"), \" accepts three arguments. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" will be name of the directive, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \" the information you can give it and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extend\"), \" is a function that has to return a (partial) field config. In more verbose terms (including \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \") you could write it like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const isFuture = (fieldName, source) => {\\n  const date = get(source, fieldName);\\n  return new Date(date) > new Date();\\n};\\n\\ncreateFieldExtension({\\n  name: \\\"isFuture\\\",\\n  args: {\\n    fieldName: \\\"String!\\\",\\n  },\\n  extend(options) {\\n    return {\\n      resolve(source) {\\n        return isFuture(options.fieldName, source);\\n      },\\n    };\\n  },\\n});\\n\")), mdx(\"p\", null, \"So the the code you\\u2019ll be using is destructuring the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"options\"), \" and passing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"source\"), \" via \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Currying\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \".\"), mdx(\"p\", null, \"After adding the field extension to the field, the final code should look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\",\n    \"metastring\": \"title=gatsby-node.js {25}\",\n    \"title\": \"gatsby-node.js\",\n    \"{25}\": true\n  }, \"const get = require(\\\"lodash.get\\\");\\n\\nexports.createSchemaCustomization = ({ actions }) => {\\n  const { createTypes, createFieldExtension } = actions;\\n\\n  const isFuture = (fieldName) => (source) => {\\n    const date = get(source, fieldName);\\n    return new Date(date) > new Date();\\n  };\\n\\n  createFieldExtension({\\n    name: \\\"isFuture\\\",\\n    args: {\\n      fieldName: \\\"String!\\\",\\n    },\\n    extend({ fieldName }) {\\n      return {\\n        resolve: isFuture(fieldName),\\n      };\\n    },\\n  });\\n\\n  createTypes(`\\n    type MarkdownRemark implements Node {\\n      isFuture: Boolean! @isFuture(fieldName: \\\"frontmatter.date\\\")\\n    }\\n  `);\\n};\\n\")), mdx(\"p\", null, \"As the date is defined in the frontmatter the fieldName is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontmatter.date\"), \". If you would place the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \" field in the frontmatter itself you would use only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"date\"), \" for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldName\"), \".\"), mdx(\"p\", null, \"Start the development server, head to GraphiQL and see that you now can query \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \" on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MarkdownRemark\"), \" nodes!\"), mdx(\"p\", null, \"You now can filter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"allMarkdownRemark\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter: { isFuture: { eq: false } }\"), \" to hide posts. See an example on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://codesandbox.io/s/blogposts-in-future-field-4iuvp\"\n  }, \"Codesandbox\"), \".\"), mdx(\"h2\", {\n    \"id\": \"where-to-go-from-here\"\n  }, \"Where to go from here\"), mdx(\"p\", null, \"Congrats, you just created a generic field extension that allows you to generate a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \" field! You can not only use that with Markdown files but with any type in the GraphQL schema.\"), mdx(\"p\", null, \"Lookup the type you want to modify in GraphiQL and add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isFuture\"), \" field where appropriate. If you\\u2019re unsure what value you have to pass into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldName\"), \", you can inspect the passed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"source\"), \" and see what\\u2019s available.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/garden/filter-future-posts-on-a-gatsby-blog","icon":"gatsby","seoLastUpdated":"2021-04-26T00:00:00.000Z","lastUpdated":"Apr 26, 2021","seoDate":"2020-01-18T00:00:00.000Z","date":"Jan 18, 2020","yearDate":"2020","tags":["Gatsby"],"timeToRead":2,"excerpt":"You can leverage Gatsby's GraphQL data layer to filter blog posts that are in the future. This  TODAY  variable allows you to e.g. buildâ€¦","parent":{"parent":{"relativePath":"2020-01-18--filter-future-posts-on-a-gatsby-blog/index.mdx"}}}},"pageContext":{"slug":"/garden/filter-future-posts-on-a-gatsby-blog"}},"staticQueryHashes":["2299006781","3050858678","4184542181","712324210"]}